# -*- coding: utf-8 -*-
"""Dropshot / StoneDrill Decrypter

This is a r2pipe based script which will be used to demonstrate the capabilities
of radare2 and Cutter (@r2gui). The script will be oficially published on a blogpost
on https://www.megabeets.net as part of series of article about radare2.

"""

__author__ = "Itay Cohen, aka Megabeets"
__email__ = "itay@megabeets.net"
__copyright__ = "Do whatever you want with this code"
__website__ = "https://www.megabeets.net"

import cutter
import zlib

# Rotate right lambda


def ror(val, r_bits, max_bits): return \
    ((val & (2**max_bits-1)) >> r_bits % max_bits) | \
    (val << (max_bits-(r_bits % max_bits)) & (2**max_bits-1))


def decode_strings(verbose=True):

    if verbose:
        print("\n%s\n\tStarting the decode of the encrypted strings\n%s\n\n" %
              ('~'*60, '~'*60))

    # Declaration of decryption-table related variables
    decryption_table = 0x41BA3C
    decryption_table_end = 0x41BA77
    decryption_table_len = decryption_table_end - decryption_table
    decryption_function = 0x4012A0

    # Analyze the binary to better detect functions and x-refs
    cutter.cmd('aa')

    # Rename the decryption function
    cutter.cmd('afn decryption_function %d' % decryption_function)

    # Dump the decryption table to a variable
    decryption_table_content = cutter.cmdj(
        "pxj %d @ %d" % (decryption_table_len, decryption_table))

    # Iterate x-refs to the decryption function
for xref in cutter.cmdj('axtj %d' % decryption_function):
    # Get the arguments passed to the decryption function: length and encrypted string
    length_arg, offsets_arg = cutter.cmdj('pdj -2 @ %d' % (xref['from']))

    # String variable to store the decrypted string
    decrypted_string = ""

    # Guard rail to avoid exception
    if (not 'val' in length_arg):
        continue

    # Manually decrypt the encrypted string
    for i in range(0, length_arg['val']):
        decrypted_string += chr(decryption_table_content[cutter.cmdj(
            'pxj 1 @ %d' % (offsets_arg['val'] + (i*2)))[0]])

    # Print the decrypted and the address it was referenced to the console
    if verbose:
        print(decrypted_string + " @ " + hex(xref['from']))

    # Add comments to each call of the decryption function
    cutter.cmd('CC Decrypted: %s @ %d' % (decrypted_string, xref['from']))


# def decrypt_resource(verbose=True):
    # Will be filled in part 2 of the series


decode_strings()

# Will be available in part 2 of the series
# decrypt_resource()

# Refresh the interface to load changes
cutter.refresh()
